/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package tpbitcoin;

import com.google.gson.Gson;
import com.google.gson.GsonBuilder;
import com.google.gson.reflect.TypeToken;
import org.bitcoinj.core.*;
import org.bitcoinj.params.UnitTestParams;

import java.io.BufferedReader;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.reflect.Type;
import java.net.URL;
import java.nio.ByteBuffer;
import java.time.YearMonth;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;

import static org.bouncycastle.asn1.x509.ObjectDigestInfo.publicKey;

public class App {



    public static void main(String[] args) {

        //Q1  hashrate
       /* double localHashrate = new HashRateEstimator(5000,5).estimate();
        System.out.println(localHashrate);*/

        // Q2: latest  block  from mainet (bitcoin blockchain) and its predecessor
        Context context   = new Context(new UnitTestParams()); // required  for working with bitcoinj
        Explorer explorer = new Explorer(); // for interacting with blockchain.info API
        Block block = explorer.getBlockFromHash(context.getParams(),explorer.getLatestHash());
        System.out.println("version : "+block.getVersion()+"\nprev Block Hash : "+block.getPrevBlockHash()+
                "\nmerkle Root : "+block.getMerkleRoot()+"\ntime : "+block.getTime()+
                "\ndifficulty Target : "+block.getDifficultyTarget()+"\nnonce : "+ block.getNonce());
        // Q3 Some TXs
        for (int i = 0; i < 2; i++) {
            System.out.println("\ntransaction "+i+1+" : "+block.getTransactions().get(i));
        }

        // Q4 Mine a new block
        Miner miner = new Miner(context.getParams());
        // empty list of tx since creating txs, even fake ones, requires some work
        ArrayList<Transaction> txs = new ArrayList<>();
        // TODO : mine a new block


// Miner un nouveau bloc en utilisant le bloc précédent, une liste vide de transactions et une clé publique
        byte[] a = new byte[1];
        a[0] = (byte) publicKey;
        Block newBlock = miner.mine(block, txs, a);

// Vérifier si le bloc miné est valide
        if (newBlock != null) {
            // Le bloc est valide, vous pouvez traiter ici
            System.out.println("Le nouveau bloc a été miné avec succès : " + newBlock);
        } else {
            // Le bloc n'est pas valide, gérer l'erreur ici
            System.out.println("Erreur lors du minage du nouveau bloc.");
        }


        System.out.println("\n");
        // Q9/Q10 energy w/ most profitable hardware
        Gson gson = new GsonBuilder()
                .registerTypeAdapter(YearMonth.class,new YearMonthAdapter())
                .create();
        List<MiningHardware> hardwares = new ArrayList<>();

        URL resource = App.class.getClassLoader().getResource("hardware.json");
        try(BufferedReader reader = new BufferedReader(new FileReader(resource.getFile()))) {
            Type listType = new TypeToken<ArrayList<MiningHardware>>(){}.getType();
            hardwares = gson.fromJson(reader,listType);
        } catch (Exception e) {
            System.err.println("error opening/reading hardware.json "+ e.getMessage());
        }



    }




}
